<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Notes for Week 4 of WDD330</title>
    <meta name="description" content="Notes for Week 4 of OneDeMillion's Portfolio for WDD 330" />

    <link rel="stylesheet" href="../css/large.css">

</head>

<body>

    <h1>Kim DeMille's Portfolio</h1>

    <h2>Week Four Notes</h2>
    <section id="exerciseEg">
        <h3>Notes on Reading</h3>
    </section>

    <section id="writtenNotesBox">
        
        <ul>
            <li>Event Bubbling - The event starts at the most specific node and flows outward to the least specific one. This is the default.<br>
            Imagine a list item contains a link. When you lover over the link or click on it. JS can trigger events on the anchor tag element, <br>
            and also any elements the anchor element sits inside.</a></li>
            <li>Event Capturing - The event starts at the least specific node and flows inwards to the most specific one.</li>
            <li>capture: true//capturing phase</li>
            <li>capture: false//bubbling phase. this is the default</li>
            <li>once: true// listens for click and then unbinds</li>
            
       </ul>
       <p>OOP</p>
       <ul>
           <li>Static - similar to class methods in other programming languages.</li>
           <li>class Dice {<br>
            constructor(sides=6) {<br>
                this.sides = sides;<br>
            }<br>
            roll() {<br>
                return Math.floor(this.sides * Math.random() + 1)<br>
            }<br>
            static description() {<br>
                return 'A way of choosing random numbers'<br>
            }<br>
        }</li>
        <li>Static methods aren't available to instances of the class.</li>
       </ul>

       <p>Prototypal Inheritance</p>
       <ul>
           <li>Javascript uses a Prototypal Inheritance modal. Meaning that every class has a prototype property that is shared by every instance of the class. </li>
       </ul>

       <p>The Prototype Property</p>
       <ul>
           <li>Using the prototype property of the class you can add properties and methods to the class.<br>
            To add a property:<br>
            Turtle.prototype.weapon = 'Hands';<br>
            To add a method:<br>
            Turtle.prototype.attack = function(){
                return `Feel the power of my ${this.weapon}!`; </li>
            <li>If there is a reference to this.weapon in the prototype attack() method, when the attack() method is called, is uses the instance's weapon<br>
            property because 'this' in the prototype always refers to the instance that actually calls the method.</li>
       </ul>
       
       <p>Finding Out The Prototype</p>
       <ul>
            <li>Ways to find the prototype of an object:</li>
            <li>constructor functions prototype property:<br>
            raph.constructor.prototype;<br>
            Returns: Turtle { attack: [Function], weapon: 'Hands' }</li>
            <li>Object.getPrototypeOf() method using object as the parameter: (preferred method)<br>
                Object.getPrototypeOf(raph);<br>
                Returns: Turtle { attack: [Function], weapon: 'Hands' }</li>
            <li>non-standard __proto__ property (known as 'double dunder'):<br>
                raph.__proto__
                Returns: Turtle { attack: [Function], weapon: 'Hands' }</li>
       </ul>

       <p>Public and Private Methods</p>
       <ul>
           <li>Methods and Properties in classes are by default public</li>
           <li>If a property is created as a variable in the class e.g. let _color = color; it becomes private</li>
           <li>Getter and setter methodsand they form a closure over this variable and provide controlled access to the property instead<br>
                e.g. this.getColor = () => _color;</li>
            <li>Private properties can only be changed in a controlled way, for e.g. through the use of if/else statements</li>
       </ul>

       <p>Object Constructor</p>
       <ul>
           <li>All objects ultimately inherit from the prototype of the Object() constructor function</li>
           <li>The prototype of the Object constructor function has a large number of methods that are inherited by all objects.<br>
            The reason why the prototype appears as an empty object literal is because all of its methods are not enumerable. </li>
            <li>Methods that are not enumerable means they will not show up when a for-in loop is used to loop through an object’s properties and methods.</li>
            <li>Good practice is for all built-in methods to be non-enumerable, and any user-defined methods to be made enumerable. This is so all the built-in <br>
                methods don’t keep showing up when looking at an object’s methods, but user-defined methods are easy to find</li>
            <li>A class can inherit from another class using the extends keyword in a class declaration</li>
            <li>Inside the child class declaration, the keyword super refers to the parent class, and can be used to access any properties and call <br>
                any methods of the parent class</li>
       </ul>

       <p>Polymorphism</p>
       <ul>
           <li>Polymorphism means that different objects can have the same method, but implement it in different ways</li>
           <li>The toString() method is a good demonstration of polymorphism, since different objects have the same method but implement it differently</li>
       </ul>

       <p>Property Attributes and Descriptors</p>
       <ul>
           <li>All object properties have the following attributes stored in a property descriptor: value, writeable, enumerable, configurable.<br>
            Value's default is undefined. The other three descriptor's default is false.</li>
            <li>Use Object.getOwnPropertyDescriptor() method to see the values</li>
            <li>Instead of using assignment, we can add properties to an object using the Object.defineProperty() method</li>
            <li>An object property descriptor can have get() and set() methods instead of a value attribute<br>
                All objects must have one or the other, they can not have both</li>
       </ul>

       <p>Creating Objects from Other Objects</p>
       <ul>
           <li>The Object() constructor function has a method called create that can be used to create a new object that is an exact copy of the object <br>
            that is provided as an argument.</li>
            <li>Extra properties can then be added to each instance using assignment</li>
            <li>Every time a new object is created using the Object.create() method, the new object inherits all the properties and methods from the parent <br>
                object, which becomes the new object’s prototype</li>
       </ul>

       <p>Binding this</p>
       <ul>
            <li>When a function is nested inside another function, which can often happen when using methods in objects, especially ones that accept callback <br>
            functions. The value of this loses its scope and points to the global object inside a nested function</li>
            <li>A common solution is to set the variable that to equal this beforethe nested function, and refer to that in the nested function instead of this</li>
            <li>The bind() method is a method for all functions and is used to set the value of this in the function. If this is provided as an argument to bind() <br>
                while it’s still in scope, any reference to this inside the nested function will be bound to the object calling the original method:</li>
            <li>ES6 introduced the for-of syntax for arrays and this does not require a nested function to be used</li>
            <li>Arrow functions were introduced in ES6, and one of the advantages of using them is that they don't have their own this context, so this remains <br>
                bound to the original object making the function call. Arrow functions should be used when anonymous functions are required in callbacks</li>
       </ul>

       <p>Composition Over Inheritance</p>
       <ul>
           <li>Composition over inheritance sees objects as building blocks that go together to make other objects rather than classes that are monolithic structures <br>
            layered on top of each other.</li>
            <li>If you do decide to use classes, it’s recommended to make them 'skinny' ― meaning they don't have too many properties and methods</li>
            <li>It's good practice when creating classes is to keep inheritance chains short. A good rule of thumb is to only inherit once, keeping the inheritance <br>
                chain to just two objects makes unpicking any issues far easier.</li>
       </ul>
    </section>
</body>


</html> 